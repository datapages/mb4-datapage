[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "ManyBabies 4",
    "section": "",
    "text": "The goal of palmerpenguins is to provide a great dataset for data exploration & visualization, as an alternative to iris.\nData were collected and made available by Dr. Kristen Gorman and the Palmer Station, Antarctica LTER, a member of the Long Term Ecological Research Network. The dataset contains data for 344 penguins. There are 3 different species of penguins in this dataset, collected from 3 islands in the Palmer Archipelago, Antarctica.\nData are available by CC-0 license in accordance with the Palmer Station LTER Data Policy and the LTER Data Access Policy for Type I data."
  },
  {
    "objectID": "about.html#palmerpenguins",
    "href": "about.html#palmerpenguins",
    "title": "ManyBabies 4",
    "section": "",
    "text": "The goal of palmerpenguins is to provide a great dataset for data exploration & visualization, as an alternative to iris.\nData were collected and made available by Dr. Kristen Gorman and the Palmer Station, Antarctica LTER, a member of the Long Term Ecological Research Network. The dataset contains data for 344 penguins. There are 3 different species of penguins in this dataset, collected from 3 islands in the Palmer Archipelago, Antarctica.\nData are available by CC-0 license in accordance with the Palmer Station LTER Data Policy and the LTER Data Access Policy for Type I data."
  },
  {
    "objectID": "analysis.html",
    "href": "analysis.html",
    "title": "ManyBabies 4",
    "section": "",
    "text": "You can access data from many_babies_4_analysis programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"datapages\")\nworkflow &lt;- user$workflow(\"many_babies_4_analysis\")\ntable &lt;- dataset$table(\"primary_data\")\n\n# load table as tidyverse tibble\ndf &lt;- table$to_tibble()\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"datapages\")\nworkflow = user.workflow(\"many_babies_4_analysis\")\ntable = dataset.table(\"primary_data\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe()\nView documentation"
  },
  {
    "objectID": "analysis.html#programmatic-access",
    "href": "analysis.html#programmatic-access",
    "title": "ManyBabies 4",
    "section": "",
    "text": "You can access data from many_babies_4_analysis programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"datapages\")\nworkflow &lt;- user$workflow(\"many_babies_4_analysis\")\ntable &lt;- dataset$table(\"primary_data\")\n\n# load table as tidyverse tibble\ndf &lt;- table$to_tibble()\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"datapages\")\nworkflow = user.workflow(\"many_babies_4_analysis\")\ntable = dataset.table(\"primary_data\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe()\nView documentation"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ManyBabies 4",
    "section": "",
    "text": "Plot = import(\"https://esm.sh/@observablehq/plot@0.6.17\")\nd = transpose(data)\n\nyaml = require(\"js-yaml\")\nconfig_file = FileAttachment(\"_config.yml\").text()\nconfig = yaml.load(config_file)\n\ndistinct_cutoff = 10\n\ndisc_types = (['string', 'boolean'])\ndisc_filter = (config?.categorical_vars)\n  ? d =&gt; config.categorical_vars.includes(d.name)\n  : d =&gt; disc_types.includes(d.type) && d.numDistinct &lt;= distinct_cutoff && d.numDistinct &gt; 1\ndisc_vars = vars.filter(disc_filter)\ndisc_opts = new Map([['', null], ...disc_vars.map(d =&gt; [d.label ? d.label : d.name, d.name])])\n\ncont_types = (['integer', 'float', 'date', 'datetime', 'time'])\ncont_filter = (config?.numerical_vars)\n  ? d =&gt; config.numerical_vars.includes(d.name)\n  : d =&gt; cont_types.includes(d.type) && d.numDistinct &gt; distinct_cutoff\ncont_vars = vars.filter(cont_filter)\ncont_opts = new Map(cont_vars.map(d =&gt; [d.label ? d.label : d.name, d.name]))\n\nx_val = config?.defaults?.x || cont_vars[0].name\ny_val = config?.defaults?.y || cont_vars[1].name\ncolor_val = config?.defaults?.color || disc_vars[0].name\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof x_var = Inputs.select(cont_opts, {value: x_val, label: \"X axis\"})\nviewof y_var = Inputs.select(cont_opts, {value: y_val, label: \"Y axis\"})\nviewof color_var = Inputs.select(disc_opts, {value: color_val, label: \"Color\"})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndefault_color = d3.schemeCategory10[0]\nplt_color = color_var || default_color\n\nall_vars = [...cont_vars, ...disc_vars]\nchannels = Object.fromEntries(all_vars.map(k =&gt; [k.name, k.name]))\n\nviewof scatter = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  inset: 8,\n   grid: true,\n      x: { tickFormat: \"\" },\n  color: { legend: true },\n  marks: [\n    Plot.dot(d, {\n      x: x_var,\n      y: y_var,\n      stroke: plt_color,\n      tip: true,\n      channels: channels\n    }),\n  ]\n})\n\nviewof x_hist = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 640/2,\n      x: { tickFormat: \"\" },\n      y: { grid: true },\n  marks: [\n    Plot.rectY(d, Plot.binX({y: \"count\"}, {x: x_var, fill: plt_color})),\n    Plot.ruleY([0])\n  ]\n})\n\nviewof y_hist = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 640/2,\n      y: { grid: true },\n  marks: [\n    Plot.rectY(d, Plot.binX({y: \"count\"}, {x: y_var, fill: plt_color})),\n    Plot.ruleY([0])\n  ]\n})\n\nhtml`&lt;div style=\"display: flex; flex-wrap: wrap; align-items: flex-end;\"&gt;\n &lt;div style=\"flex-basis: 25%\"&gt; ${viewof y_hist} &lt;/div&gt;\n &lt;div style=\"flex-basis: 50%\"&gt; ${viewof scatter} &lt;/div&gt;\n &lt;div style=\"flex-basis: 25%\"&gt; ${viewof x_hist} &lt;/div&gt;\n&lt;/div&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ne = transpose(effects_data)\n\n_vars = ({\n               lab_id: { label: \"Lab\"                        },\n            condition: { label: \"Condition\"                  },\n               tested: { label: \"N tested\"                   },\n    chose_helper_mean: { label: \"Proportion choosing helper\" },\n         chose_helper: { label: \"N choosing helper\"          },\n             ci_lower: { label: \"CI lower\"                   },\n             ci_upper: { label: \"CI upper\"                   },\n               method: { label: \"Method\"                     },\n   exclusion_eligible: { label: \"Exclusion rate\"             },\nchoice_exclusion_rate: { label: \"Non-choice rate\"            },\n         visual_angle: { label: \"Visual angle\"               },\n               //region: { label: \"Region\"                     },\n})\n\neffects_vars = ({\n    y: \"lab_id\",\n    x: \"chose_helper_mean\",\n   x1: \"ci_lower\",\n   x2: \"ci_upper\",\n    r: \"tested\",\n   fx: \"condition\",\n  col: effects_color_var,\n})\n\n\nfx_ref = \"social\"\n\ncolor_opts = ([\n  \"condition\",\n  \"method\",\n  \"region\",\n  \"visual_angle\",\n  \"exclusion_eligible\",\n  \"choice_exclusion_rate\"\n])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\neffects_channels = Object.fromEntries(Object.entries(effects_vars).map(([k, v]) =&gt; [_vars[v].label, v]))\nfx_vals = [...new Set(e.map(x =&gt; x[effects_vars.fx]))].map(x =&gt; ({v: x, ref: x === fx_ref}))\nfx_vals_sorted = ([...fx_vals.filter(({ref}) =&gt; ref), ...fx_vals.filter(({ref}) =&gt; !ref)]).map(x =&gt; x.v)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof effects_color_var = Inputs.select(color_opts, {label: \"Color\"})\n\n\n\n\n\n\n\ncolor_type = vars.filter(v =&gt; v.name === effects_color_var)[0].type\ncolor_scheme = disc_types.includes(color_type) ? \"observable10\" : \"viridis\"\n\nPlot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  marginLeft: 150,\n  width: 1000,\n  x: { label: _vars[effects_vars.x].label, line: true },\n  y: { label: _vars[effects_vars.y].label },\n  fx: { label: _vars[effects_vars.fx].label, domain: fx_vals_sorted },\n  color: {\n    label: _vars[effects_vars.col].label,\n    legend: effects_vars.col !== effects_vars.fx,\n    scheme: color_scheme\n  },\n  marks: [\n    Plot.ruleX([0.5], { stroke: \"lightgrey\", strokeDasharray: [3, 3] }),\n    Plot.ruleY(e, { y: effects_vars.y, stroke: \"lightgrey\" }),\n    Plot.link(e, {\n      fx: effects_vars.fx,\n      y: effects_vars.y,\n      x1: effects_vars.x1,\n      x2: effects_vars.x2\n    }),\n    Plot.dot(e, {\n      fx: effects_vars.fx,\n      x: effects_vars.x,\n      y: effects_vars.y,\n      stroke: effects_vars.col,\n      fill: effects_vars.col,\n      r: effects_vars.r,\n      // sort descending by x value within reference level of fx\n      sort: {\n          y: \"data\",\n          reduce: (dy) =&gt; dy.find(v =&gt; v[effects_vars.fx] === fx_ref)?.[effects_vars.x],\n          order: \"descending\"\n      }\n    }),\n    Plot.tip(e, Plot.pointerY({\n      fx: effects_vars.fx,\n      x: effects_vars.x,\n      y: effects_vars.y,\n      stroke: effects_vars.col,\n      channels: effects_channels\n    })),\n  ]\n})"
  }
]